Name: David Singer
Email: dsinger1@hawk.iit.edu
ITMD-542-02 Full-Stack Web Development - Final Project
Git Repository: https://github.com/SingerDavid/movie.me/tree/api
Development Environment:
- This is a Node JS Express Generated Application utilizing REST API architecture and follows the PUG html template styles. The backend connects to a serverless DB system called Atlas utilizing MongoDB DB.
Installation:
- To run this program simply download the files to your local repository from the github link and then proceed to run "npm install" in your terminal - this will install all of the listed dependencies required to run this project on your computer. Then, add the attached .env file (given to you directly from me not the Github link) and then type "npm install dotenv" in the terminal, drag and drop the .env file into the project within the main folder. From there, in the terminal type "npm start". Then proceed to your favorite internet browsing application and navigate to localhost 3000. Follow our template-guidebook to experiment with the application.

Project Run-through:
- To use a pre-set template that I have generated go ahead and login using "example@example.com" and a password of "password123". Since some data is already present - feel free to edit the interface as you see fit. You can also click on the "Find Movies" in the top navigational pane. Then go ahead and continue with the flow. Once finished and movie recommendations have loaded add the ones of interest and then click back to your profile using the button at the top or by clicking on the logo "Movie.Me". From there, you will see all of your additions in the next watches section.
- If you wish to create your own account. Please do so, and for best results before getting movie recommendations it is best to add some of your top favorite movies as this is what mostly affects your results.

Insights and Results:
- The biggest challenge I had was at first attempting to not touch the database until absolutely necessary. This included connecting the user and then storing all information within a session, all edits in a session, and it was only going to be pushed to the database once ready. This cause a few problems, some of which didn't make too much sense and might have been my poor execution as session storage can get tricky - especially within the use case I wanted. I realized it was best to switch to direct edits and provisions to the database as it fit best with the changes I was constantly making, especially with transferring the user across different pages back and fourth whilst also wanting to maintain accurate data that is up to date. So, having trouble with updating session storage was causing loading problems, which might have been associated with cookies not clearing or updating upon returning too a previous page. Thus, changing this to direct updates gave me real time data allowing proper CRUD executions and limiting errors. Challenges for me was just trying to decide how I wanted to go about the set-up and the interface, although I am not pleased with it, it does suffice. The toughest challenge I had at the beginning was interfacing with the OpenAI API in which documentation was not equivalent or beneficial, I ran into numerous problems, some of which many have not solved and could be a problem within node packages. I tried a few different types of code and calls to the API to get it to work, but nothing went through. I finally, after viewing many case studies and mini projects by others who spent a lot of time identifying what works I pieced together something that would fit my applicational use. Once I got that working I realized the API engine for AI models that I wanted were not suited for the type of call I was making. So, I jumped back into the research and again got stuck, but I was able to find someone on youtube who seemed to have an extensive knowledge about the API calls and was able to give me necessary information to execute the engine I wanted with the proper properties. From there, it was just formulating a chat bot to provide me with specific results and then abstracting that result into a JSON format that will be displayed to the user as inter-faceable DOM elements.